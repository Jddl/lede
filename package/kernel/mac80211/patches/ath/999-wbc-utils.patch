--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -150,6 +150,25 @@ struct ath_common {
 	enum ath_device_state state;
 	unsigned long op_flags;
 	u32 chan_bw;
+	
+	// txpower custom switch 
+	u8 txpower_custom;
+	// txpower in dBm
+	u8 txpower_b_high;
+	u8 txpower_b_low;
+	u8 txpower_b_rate;
+	u8 txpower_g_high;
+	u8 txpower_g_low;
+	u8 txpower_g_rate;
+	u8 txpower_n_high;
+	u8 txpower_n_low;
+	u8 txpower_n_rate;
+	// txpower debug
+	u8 txpower_debug;
+
+	// Ant. Diversity custom
+	u8 ant_div_ctl;
+	u8 ant_custom_en;
 
 	struct ath_ani ani;
 
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3732,6 +3732,8 @@ static void ar9003_hw_ant_ctrl_apply(str
 		/* enable_lnadiv */
 		regval &= (~AR_PHY_ANT_DIV_LNADIV);
 		regval |= ((value >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
+		if ((1 == common->ant_custom_en) && (common->ant_div_ctl & 0x10))
+			regval |= 1 << AR_PHY_ANT_DIV_LNADIV_S;
 
 		if (AR_SREV_9485(ah) && common->bt_ant_diversity)
 			regval |= AR_ANT_DIV_ENABLE;
@@ -3770,6 +3772,9 @@ static void ar9003_hw_ant_ctrl_apply(str
 		    && common->bt_ant_diversity)
 			regval |= AR_FAST_DIV_ENABLE;
 
+		if ((1 == common->ant_custom_en) && (common->ant_div_ctl & 0x80))
+			regval |= AR_FAST_DIV_ENABLE;
+
 		REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
 
 		if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
@@ -3782,11 +3787,24 @@ static void ar9003_hw_ant_ctrl_apply(str
 				     AR_PHY_ANT_DIV_ALT_LNACONF |
 				     AR_PHY_ANT_DIV_ALT_GAINTB |
 				     AR_PHY_ANT_DIV_MAIN_GAINTB));
-			/* by default use LNA1 for the main antenna */
-			regval |= (ATH_ANT_DIV_COMB_LNA1 <<
-				   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
-			regval |= (ATH_ANT_DIV_COMB_LNA2 <<
-				   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+			if (1 == common->ant_custom_en) {
+				regval |= (common->ant_div_ctl & 0x40)? 
+					(AR_PHY_ANT_DIV_MAIN_GAINTB << AR_PHY_ANT_DIV_MAIN_GAINTB_S): 0;
+				regval |= (common->ant_div_ctl & 0x20)? 
+					(AR_PHY_ANT_DIV_ALT_GAINTB << AR_PHY_ANT_DIV_ALT_GAINTB_S): 0;
+				regval |= (common->ant_div_ctl & 0x0C)? 
+					(AR_PHY_ANT_DIV_MAIN_LNACONF << AR_PHY_ANT_DIV_MAIN_LNACONF_S): 0;
+				regval |= (common->ant_div_ctl & 0x03)? 
+					(AR_PHY_ANT_DIV_ALT_LNACONF << AR_PHY_ANT_DIV_ALT_LNACONF_S): 0;
+			} else {
+				
+				/* by default use LNA1 for the main antenna */
+				regval |= (ATH_ANT_DIV_COMB_LNA1 <<
+					   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+				regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+					   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+				
+			}
 			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 		}
 	}
@@ -5234,7 +5252,7 @@ static void ar9003_hw_set_power_per_rate
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ar9300_eeprom *pEepData = &ah->eeprom.ar9300_eep;
 	u16 twiceMaxEdgePower;
-	int i;
+	int i, j;
 	u16 scaledPower = 0, minCtlPower;
 	static const u16 ctlModesFor11a[] = {
 		CTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40
@@ -5251,157 +5269,270 @@ static void ar9003_hw_set_power_per_rate
 	u8 ctlNum;
 	u16 twiceMinEdgePower;
 	bool is2ghz = IS_CHAN_2GHZ(chan);
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
 
 	ath9k_hw_get_channel_centers(ah, chan, &centers);
 	scaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,
 						antenna_reduction);
-
-	if (is2ghz) {
-		/* Setup for CTL modes */
-		/* CTL_11B, CTL_11G, CTL_2GHT20 */
-		numCtlModes =
-			ARRAY_SIZE(ctlModesFor11g) -
-				   SUB_NUM_CTL_MODES_AT_2G_40;
-		pCtlMode = ctlModesFor11g;
-		if (IS_CHAN_HT40(chan))
-			/* All 2G CTL's */
-			numCtlModes = ARRAY_SIZE(ctlModesFor11g);
+	
+	if (common->txpower_custom == 1) {
+		// Use custom txpower					
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;	
+		
+		// set 802.11b power
+		for (i = ALL_TARGET_LEGACY_1L_5L; i <= ALL_TARGET_LEGACY_11S; i++) {
+			pPwrArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			pPwrArray[ALL_TARGET_LEGACY_11S] = txp_bh;
+			pPwrArray[ALL_TARGET_LEGACY_11L] = txp_bh;
+		case 5:
+		case 2:
+		case 1:
+			pPwrArray[ALL_TARGET_LEGACY_5S] = txp_bh;
+			pPwrArray[ALL_TARGET_LEGACY_1L_5L] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = ALL_TARGET_LEGACY_6_24; i <= ALL_TARGET_LEGACY_54; i++) {
+			pPwrArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+		case 54: 
+			pPwrArray[ALL_TARGET_LEGACY_54] = txp_gh;
+		case 48: 
+			pPwrArray[ALL_TARGET_LEGACY_48] = txp_gh;
+		case 36: 
+			pPwrArray[ALL_TARGET_LEGACY_36] = txp_gh;
+		case 24: 
+		case 18: 
+		case 12: 
+		case 9: 
+		case 6: 
+			pPwrArray[ALL_TARGET_LEGACY_6_24] = txp_gh; 
+			break;
+		}
+		// 802.11n HT20 power
+		for (i = ALL_TARGET_HT20_0_8_16; i <= ALL_TARGET_HT20_23; i++) {
+			pPwrArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+		case 7: 
+			pPwrArray[ALL_TARGET_HT20_23] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_15] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_7] = txp_nh;
+		case 6: 
+			pPwrArray[ALL_TARGET_HT20_22] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_14] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_6] = txp_nh;
+		case 5: 
+			pPwrArray[ALL_TARGET_HT20_21] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_13] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_5] = txp_nh;
+		case 4: 
+			pPwrArray[ALL_TARGET_HT20_20] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_12] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_4] = txp_nh;
+		case 3: 
+		case 2: 
+		case 1: 
+			pPwrArray[ALL_TARGET_HT20_1_3_9_11_17_19] = txp_nh;
+		case 0: 
+			pPwrArray[ALL_TARGET_HT20_0_8_16] = txp_nh; 
+			break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = ALL_TARGET_HT40_0_8_16; i <ar9300RateSize ; i++) {
+			pPwrArray[i] = txp_nl;
+		}
+		
+		// print to dmesg
+		printk("ath: ar9003_eeprom: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: ar9003_eeprom: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: ar9003_eeprom: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+		//printk("Note: ar9003 uses the same power on b:1,2,5, g:6,9,12,18,24 or n:1,2,3\n");
+		// debug: print pPwrArray
+		if (common->txpower_debug) {
+			printk("ath: ar9003_eeprom: TX Power Debug: pPwrArray[]: \n");
+			for (j=0; j<(ar9300RateSize/8)+1; j++) {
+				for (i=0; i<8; i++) {
+					printk("%d ", pPwrArray[j*8+i]);
+				}
+				printk("\n");
+			}
+		}
+		return;
+		
 	} else {
-		/* Setup for CTL modes */
-		/* CTL_11A, CTL_5GHT20 */
-		numCtlModes = ARRAY_SIZE(ctlModesFor11a) -
-					 SUB_NUM_CTL_MODES_AT_5G_40;
-		pCtlMode = ctlModesFor11a;
-		if (IS_CHAN_HT40(chan))
-			/* All 5G CTL's */
-			numCtlModes = ARRAY_SIZE(ctlModesFor11a);
-	}
-
-	/*
-	 * For MIMO, need to apply regulatory caps individually across
-	 * dynamically running modes: CCK, OFDM, HT20, HT40
-	 *
-	 * The outer loop walks through each possible applicable runtime mode.
-	 * The inner loop walks through each ctlIndex entry in EEPROM.
-	 * The ctl value is encoded as [7:4] == test group, [3:0] == test mode.
-	 */
-	for (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {
-		bool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||
-			(pCtlMode[ctlMode] == CTL_2GHT40);
-		if (isHt40CtlMode)
-			freq = centers.synth_center;
-		else if (pCtlMode[ctlMode] & EXT_ADDITIVE)
-			freq = centers.ext_center;
-		else
-			freq = centers.ctl_center;
-
-		ath_dbg(common, REGULATORY,
-			"LOOP-Mode ctlMode %d < %d, isHt40CtlMode %d, EXT_ADDITIVE %d\n",
-			ctlMode, numCtlModes, isHt40CtlMode,
-			(pCtlMode[ctlMode] & EXT_ADDITIVE));
-
-		/* walk through each CTL index stored in EEPROM */
+		// Use driver controlled txpower
 		if (is2ghz) {
-			ctlIndex = pEepData->ctlIndex_2G;
-			ctlNum = AR9300_NUM_CTLS_2G;
+			/* Setup for CTL modes */
+			/* CTL_11B, CTL_11G, CTL_2GHT20 */
+			numCtlModes =
+				ARRAY_SIZE(ctlModesFor11g) -
+				   	SUB_NUM_CTL_MODES_AT_2G_40;
+			pCtlMode = ctlModesFor11g;
+			if (IS_CHAN_HT40(chan))
+				/* All 2G CTL's */
+				numCtlModes = ARRAY_SIZE(ctlModesFor11g);
 		} else {
-			ctlIndex = pEepData->ctlIndex_5G;
-			ctlNum = AR9300_NUM_CTLS_5G;
+			/* Setup for CTL modes */
+			/* CTL_11A, CTL_5GHT20 */
+			numCtlModes = ARRAY_SIZE(ctlModesFor11a) -
+					 	SUB_NUM_CTL_MODES_AT_5G_40;
+			pCtlMode = ctlModesFor11a;
+			if (IS_CHAN_HT40(chan))
+				/* All 5G CTL's */
+				numCtlModes = ARRAY_SIZE(ctlModesFor11a);
 		}
-
-		twiceMaxEdgePower = MAX_RATE_POWER;
-		for (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {
+	
+		/*
+	 	* For MIMO, need to apply regulatory caps individually across
+	 	* dynamically running modes: CCK, OFDM, HT20, HT40
+	 	*
+	 	* The outer loop walks through each possible applicable runtime mode.
+	 	* The inner loop walks through each ctlIndex entry in EEPROM.
+	 	* The ctl value is encoded as [7:4] == test group, [3:0] == test mode.
+	 	*/
+		for (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {
+			bool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||
+				(pCtlMode[ctlMode] == CTL_2GHT40);
+			if (isHt40CtlMode)
+				freq = centers.synth_center;
+			else if (pCtlMode[ctlMode] & EXT_ADDITIVE)
+				freq = centers.ext_center;
+			else
+				freq = centers.ctl_center;
+	
 			ath_dbg(common, REGULATORY,
-				"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",
-				i, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],
-				chan->channel);
-
-			/*
-			 * compare test group from regulatory
-			 * channel list with test mode from pCtlMode
-			 * list
-			 */
-			if ((((cfgCtl & ~CTL_MODE_M) |
-			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
-				ctlIndex[i]) ||
-			    (((cfgCtl & ~CTL_MODE_M) |
-			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
-			     ((ctlIndex[i] & CTL_MODE_M) |
-			       SD_NO_CTL))) {
-				twiceMinEdgePower =
-				  ar9003_hw_get_max_edge_power(pEepData,
-							       freq, i,
-							       is2ghz);
-
-				if ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL)
-					/*
-					 * Find the minimum of all CTL
-					 * edge powers that apply to
-					 * this channel
-					 */
-					twiceMaxEdgePower =
-						min(twiceMaxEdgePower,
-						    twiceMinEdgePower);
-				else {
-					/* specific */
-					twiceMaxEdgePower = twiceMinEdgePower;
-					break;
+				"LOOP-Mode ctlMode %d < %d, isHt40CtlMode %d, EXT_ADDITIVE %d\n",
+				ctlMode, numCtlModes, isHt40CtlMode,
+				(pCtlMode[ctlMode] & EXT_ADDITIVE));
+	
+			/* walk through each CTL index stored in EEPROM */
+			if (is2ghz) {
+				ctlIndex = pEepData->ctlIndex_2G;
+				ctlNum = AR9300_NUM_CTLS_2G;
+			} else {
+				ctlIndex = pEepData->ctlIndex_5G;
+				ctlNum = AR9300_NUM_CTLS_5G;
+			}
+	
+			twiceMaxEdgePower = MAX_RATE_POWER;
+			for (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {
+				ath_dbg(common, REGULATORY,
+					"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",
+					i, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],
+					chan->channel);
+	
+				/*
+			 	* compare test group from regulatory
+			 	* channel list with test mode from pCtlMode
+			 	* list
+			 	*/
+				if ((((cfgCtl & ~CTL_MODE_M) |
+			       	(pCtlMode[ctlMode] & CTL_MODE_M)) ==
+					ctlIndex[i]) ||
+			    	(((cfgCtl & ~CTL_MODE_M) |
+			       	(pCtlMode[ctlMode] & CTL_MODE_M)) ==
+			     	((ctlIndex[i] & CTL_MODE_M) |
+			       	SD_NO_CTL))) {
+					twiceMinEdgePower =
+				  	ar9003_hw_get_max_edge_power(pEepData,
+							       	freq, i,
+							       	is2ghz);
+	
+					if ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL)
+						/*
+					 	* Find the minimum of all CTL
+					 	* edge powers that apply to
+					 	* this channel
+					 	*/
+						twiceMaxEdgePower =
+							min(twiceMaxEdgePower,
+						    	twiceMinEdgePower);
+					else {
+						/* specific */
+						twiceMaxEdgePower = twiceMinEdgePower;
+						break;
+					}
 				}
 			}
-		}
-
-		minCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);
-
-		ath_dbg(common, REGULATORY,
-			"SEL-Min ctlMode %d pCtlMode %d 2xMaxEdge %d sP %d minCtlPwr %d\n",
-			ctlMode, pCtlMode[ctlMode], twiceMaxEdgePower,
-			scaledPower, minCtlPower);
-
-		/* Apply ctl mode to correct target power set */
-		switch (pCtlMode[ctlMode]) {
-		case CTL_11B:
-			for (i = ALL_TARGET_LEGACY_1L_5L;
-			     i <= ALL_TARGET_LEGACY_11S; i++)
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-			break;
-		case CTL_11A:
-		case CTL_11G:
-			for (i = ALL_TARGET_LEGACY_6_24;
-			     i <= ALL_TARGET_LEGACY_54; i++)
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-			break;
-		case CTL_5GHT20:
-		case CTL_2GHT20:
-			for (i = ALL_TARGET_HT20_0_8_16;
-			     i <= ALL_TARGET_HT20_23; i++) {
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-				if (ath9k_hw_mci_is_enabled(ah))
-					pPwrArray[i] =
-						(u8)min((u16)pPwrArray[i],
-						ar9003_mci_get_max_txpower(ah,
-							pCtlMode[ctlMode]));
+	
+			minCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);
+	
+			ath_dbg(common, REGULATORY,
+				"SEL-Min ctlMode %d pCtlMode %d 2xMaxEdge %d sP %d minCtlPwr %d\n",
+				ctlMode, pCtlMode[ctlMode], twiceMaxEdgePower,
+				scaledPower, minCtlPower);
+	
+			/* Apply ctl mode to correct target power set */
+			switch (pCtlMode[ctlMode]) {
+			case CTL_11B:
+				for (i = ALL_TARGET_LEGACY_1L_5L;
+			     	i <= ALL_TARGET_LEGACY_11S; i++)
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+				break;
+			case CTL_11A:
+			case CTL_11G:
+				for (i = ALL_TARGET_LEGACY_6_24;
+			     	i <= ALL_TARGET_LEGACY_54; i++)
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+				break;
+			case CTL_5GHT20:
+			case CTL_2GHT20:
+				for (i = ALL_TARGET_HT20_0_8_16;
+			     	i <= ALL_TARGET_HT20_23; i++) {
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+					if (ath9k_hw_mci_is_enabled(ah))
+						pPwrArray[i] =
+							(u8)min((u16)pPwrArray[i],
+							ar9003_mci_get_max_txpower(ah,
+								pCtlMode[ctlMode]));
+				}
+				break;
+			case CTL_5GHT40:
+			case CTL_2GHT40:
+				for (i = ALL_TARGET_HT40_0_8_16;
+			     	i <= ALL_TARGET_HT40_23; i++) {
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+					if (ath9k_hw_mci_is_enabled(ah))
+						pPwrArray[i] =
+							(u8)min((u16)pPwrArray[i],
+							ar9003_mci_get_max_txpower(ah,
+								pCtlMode[ctlMode]));
+				}
+				break;
+			default:
+				break;
 			}
-			break;
-		case CTL_5GHT40:
-		case CTL_2GHT40:
-			for (i = ALL_TARGET_HT40_0_8_16;
-			     i <= ALL_TARGET_HT40_23; i++) {
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-				if (ath9k_hw_mci_is_enabled(ah))
-					pPwrArray[i] =
-						(u8)min((u16)pPwrArray[i],
-						ar9003_mci_get_max_txpower(ah,
-							pCtlMode[ctlMode]));
+		} /* end ctl mode checking */
+		
+		// debug: print pPwrArray
+		if (common->txpower_debug) {
+			printk("ath: ar9003_eeprom: TX Power Debug: pPwrArray[]: \n");
+			for (j=0; j<(ar9300RateSize/8)+1; j++) {
+				for (i=0; i<8; i++) {
+					printk("%d ", pPwrArray[j*8+i]);
+				}
+				printk("\n");
 			}
-			break;
-		default:
-			break;
 		}
-	} /* end ctl mode checking */
+	}
 }
 
 static inline u8 mcsidx_to_tgtpwridx(unsigned int mcs_idx, u8 base_pwridx)
--- a/drivers/net/wireless/ath/ath9k/common-init.c
+++ b/drivers/net/wireless/ath/ath9k/common-init.c
@@ -22,7 +22,7 @@
 	.band = NL80211_BAND_2GHZ, \
 	.center_freq = (_freq), \
 	.hw_value = (_idx), \
-	.max_power = 20, \
+	.max_power = 30, \
 }
 
 #define CHAN5G(_freq, _idx) { \
@@ -36,7 +36,30 @@
  * on 5 MHz steps, we support the channels which we know
  * we have calibration data for all cards though to make
  * this static */
-static const struct ieee80211_channel ath9k_2ghz_chantable[] = {
+static const struct ieee80211_channel ath9k_2ghz_chantable[] = {	
+	// 61 Channels 2.3G~2.5G
+	CHAN2G(2302, 39), /* Channel XX */
+	CHAN2G(2307, 40), /* Channel XX */
+	CHAN2G(2312, 41), /* Channel XX */
+	CHAN2G(2317, 42), /* Channel XX */
+	CHAN2G(2322, 43), /* Channel XX */
+	CHAN2G(2327, 44), /* Channel XX */
+	CHAN2G(2332, 45), /* Channel XX */
+	CHAN2G(2337, 46), /* Channel XX */
+	CHAN2G(2342, 47), /* Channel XX */
+	CHAN2G(2347, 48), /* Channel XX */
+	CHAN2G(2352, 49), /* Channel XX */
+	CHAN2G(2357, 50), /* Channel XX */
+	CHAN2G(2362, 51), /* Channel XX */
+	CHAN2G(2367, 52), /* Channel XX */
+	CHAN2G(2372, 53), /* Channel XX */
+	CHAN2G(2377, 54), /* Channel XX */
+	CHAN2G(2382, 55), /* Channel XX */
+	CHAN2G(2387, 56), /* Channel XX */
+	CHAN2G(2392, 57), /* Channel XX */
+	CHAN2G(2397, 58), /* Channel XX */
+	CHAN2G(2402, 59), /* Channel XX */
+	CHAN2G(2407, 60), /* Channel XX */
 	CHAN2G(2412, 0), /* Channel 1 */
 	CHAN2G(2417, 1), /* Channel 2 */
 	CHAN2G(2422, 2), /* Channel 3 */
@@ -49,8 +72,33 @@ static const struct ieee80211_channel at
 	CHAN2G(2457, 9), /* Channel 10 */
 	CHAN2G(2462, 10), /* Channel 11 */
 	CHAN2G(2467, 11), /* Channel 12 */
-	CHAN2G(2472, 12), /* Channel 13 */
-	CHAN2G(2484, 13), /* Channel 14 */
+	CHAN2G(2472, 12), /* Channel XX */
+	CHAN2G(2477, 13), /* Channel XX */
+	CHAN2G(2482, 14), /* Channel XX */
+	CHAN2G(2484, 15), /* Channel XX */	// JP Compatible
+	CHAN2G(2487, 16), /* Channel XX */
+	CHAN2G(2492, 17), /* Channel XX */
+	CHAN2G(2497, 18), /* Channel XX */
+	CHAN2G(2502, 19), /* Channel XX */
+	CHAN2G(2507, 20), /* Channel XX */
+	CHAN2G(2512, 21), /* Channel XX */
+	CHAN2G(2517, 22), /* Channel XX */
+	CHAN2G(2522, 23), /* Channel XX */
+	CHAN2G(2527, 24), /* Channel XX */
+	CHAN2G(2532, 25), /* Channel XX */
+	CHAN2G(2537, 26), /* Channel XX */
+	CHAN2G(2542, 27), /* Channel XX */
+	CHAN2G(2547, 28), /* Channel XX */
+	CHAN2G(2552, 29), /* Channel XX */
+	CHAN2G(2557, 30), /* Channel XX */
+	CHAN2G(2562, 31), /* Channel XX */
+	CHAN2G(2567, 32), /* Channel XX */
+	CHAN2G(2572, 33), /* Channel XX */
+	CHAN2G(2577, 34), /* Channel XX */
+	CHAN2G(2582, 35), /* Channel XX */
+	CHAN2G(2587, 36), /* Channel XX */
+	CHAN2G(2592, 37), /* Channel XX */
+	CHAN2G(2597, 38), /* Channel XX */
 };
 
 /* Some 5 GHz radios are actually tunable on XXXX-YYYY
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -1565,6 +1565,221 @@ static const struct file_operations fops
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_txpower_custom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf, 
+		"txpower custom: \n"
+		"802.11b: rate %d Mbps, high %d dBm, low %d dBm\n"
+		"802.11g: rate %d Mbps, high %d dBm, low %d dBm\n"
+		"802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+		common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low, 
+		common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low, 
+		common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low 
+	);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_txpower_custom(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int i, j, ret, int_rate, int_power_high, int_power_low;
+	char wifi_mode = '\0';
+	u8 rate = 0, power_high = 0, power_low = 0;
+	u8 b_rate_list[] = {1, 2, 5, 11};
+	u8 g_rate_list[] = {6, 9, 12, 18, 24, 36, 48, 54};
+	
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%c:%d:%d:%d", 
+					&wifi_mode, &int_rate, &int_power_high, &int_power_low);
+	
+	rate = (u8)int_rate;
+	power_high = (u8)int_power_high;
+	power_low = (u8)int_power_low;
+	
+	// check input
+	// to-do: rewrite this
+	j = 0;
+	if (wifi_mode == 'b') {
+		// check if the input rate is in b_rate_list[]
+		for (i=0; i<sizeof(b_rate_list); i++) {
+			if (rate == b_rate_list[i]) {
+				j = 1;
+				break;
+			}
+		}
+		if (j == 0) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'g') {
+		for (i=0; i<sizeof(g_rate_list); i++) {
+			if (rate == g_rate_list[i]) {
+				j = 1;
+				break;
+			}
+		}
+		if (j == 0) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'n') {
+		if (rate < 0 || rate > 7) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'd') {
+		// debug switch
+		if (rate == 0 && power_high == 0 && power_low == 0) {
+			common->txpower_debug = 0;
+			return count;
+		} else if (rate == 1 && power_high == 1 && power_low == 1) {
+			common->txpower_debug = 1;
+			return count;
+		} else {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 's') {
+		// custom power switch
+		if (rate == 0 && power_high == 0 && power_low == 0) {
+			common->txpower_custom = 0;
+			return count;
+		} else if (rate == 1 && power_high == 1 && power_low == 1) {
+			common->txpower_custom = 1;
+			return count;
+		} else {
+			return -EINVAL;
+		}
+	}
+	else {
+		return -EINVAL;
+	}
+	if (power_high < 0 || power_high > 30 || 
+		power_low < 0  || power_low > 30  || 
+		power_high < power_low) {
+		return -EINVAL;
+	}
+
+	// write to ath_common
+	if (wifi_mode == 'b') {
+		common->txpower_b_high = power_high;
+		common->txpower_b_low = power_low;
+		common->txpower_b_rate = rate;
+	} else if (wifi_mode == 'g') {
+		common->txpower_g_high = power_high;
+		common->txpower_g_low = power_low;
+		common->txpower_g_rate = rate;
+	} else if (wifi_mode == 'n') {
+		common->txpower_n_high = power_high;
+		common->txpower_n_low = power_low;
+		common->txpower_n_rate = rate;
+	}
+
+	// set power
+	mutex_lock(&sc->mutex);
+	ath9k_set_txpower(sc, NULL);
+	mutex_unlock(&sc->mutex);
+
+	return count;
+}
+
+static const struct file_operations fops_txpower_custom = {
+	.read = read_file_txpower_custom,
+	.write = write_file_txpower_custom,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_antdiv_custom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf, 
+		"antdiv custom: \n"
+		"Ant. Diversity Enable: %d \n"
+		"Ant. Diversity Control: %d \n",
+		common->ant_custom_en,
+		common->ant_div_ctl 
+	);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+/*
+ * original ant div in debugfs is read-only.
+ * this is a dirty hack, ant div will be set in eeprom ops set_board_info 
+ * ar9003_eeprom, eeprom_4k
+ * 
+ * echo "1:255" > <debugfs>/antdiv_custom
+ * echo "0:0" > <debugfs>/antdiv_custom
+ *  
+ * common->ant_custom_en: 0-disable, 1-enable
+ * common->ant_div_ctl:
+ *	bit	|	function
+ * ---------------------------
+ *	7	|	ctl1->ant_fast_div
+ *	6	|	ctl1->main_gaintb
+ *	5	|	ctl1->alt_gaintb
+ *	4	|	ctl1->div_lnadiv
+ *	3:2	|	ctl2->main_lnaconf
+ *	1:0 	|	ctl2->alt_lnaconf
+ */
+static ssize_t write_file_antdiv_custom(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int ret, int_en, int_ctl;
+	u8 en = 0, ctl = 0;
+	
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%d:%d", &int_en, &int_ctl);
+	
+	ctl = (u8)(int_ctl);
+	en = (u8)(int_en);
+
+	// lock
+	mutex_lock(&sc->mutex);
+	// write to ath_common
+	common->ant_div_ctl = ctl;
+	common->ant_custom_en = en;
+	// update setting
+	// call IEEE80211_CONF_CHANGE_CHANNEL will update ant. div. setting
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+	// unlock
+	mutex_unlock(&sc->mutex);
+
+	return count;
+}
+
+static const struct file_operations fops_antdiv_custom = {
+	.read = read_file_antdiv_custom,
+	.write = write_file_antdiv_custom,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -1663,6 +1878,11 @@ int ath9k_init_debug(struct ath_hw *ah)
 
 	debugfs_create_file("nf_override", 0600,
 			    sc->debug.debugfs_phy, sc, &fops_nf_override);
+				
+	debugfs_create_file("txpower_custom", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_txpower_custom);
 
+	debugfs_create_file("antdiv_custom", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_antdiv_custom);
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
@@ -18,6 +18,9 @@
 #include "hw.h"
 #include "ar9002_phy.h"
 
+extern u8 tx_power_man;
+extern u8 thresh62_man;
+
 static int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)
 {
 	u16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);
@@ -582,10 +585,12 @@ static void ath9k_hw_4k_set_txpower(stru
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;
 	struct modal_eep_4k_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
-	int i;
-
+	int i, j;
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
+	
 	memset(ratesArray, 0, sizeof(ratesArray));
 
 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)
@@ -609,10 +614,100 @@ static void ath9k_hw_4k_set_txpower(stru
 
 	if (test)
 	    return;
-
-	for (i = 0; i < Ar5416RateSize; i++)
+	
+	for (i = 0; i < Ar5416RateSize; i++) 
 		ratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;
 
+	if (common->txpower_custom == 1) {
+		// Use custom txpower
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;
+		
+		// set 802.11b power
+		for (i = rate1l; i <= rateXr; i++) {
+			ratesArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			ratesArray[rate11l] = txp_bh;
+			ratesArray[rate11s] = txp_bh;
+		case 5:
+			ratesArray[rate5_5l] = txp_bh;
+			ratesArray[rate5_5s] = txp_bh;
+		case 2:
+			ratesArray[rate2l] = txp_bh;
+			ratesArray[rate2s] = txp_bh;
+		case 1:
+			ratesArray[rate1l] = txp_bh;
+			ratesArray[rateXr] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = rate6mb; i <= rate54mb; i++) {
+			ratesArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+			case 54: ratesArray[rate54mb] = txp_gh;
+			case 48: ratesArray[rate48mb] = txp_gh;
+			case 36: ratesArray[rate36mb] = txp_gh;
+			case 24: ratesArray[rate24mb] = txp_gh;
+			case 18: ratesArray[rate18mb] = txp_gh;
+			case 12: ratesArray[rate12mb] = txp_gh;
+			case 9: ratesArray[rate9mb]   = txp_gh;
+			case 6: ratesArray[rate6mb]   = txp_gh; break;
+		}
+	
+		// 802.11n HT20 power
+		for (i = rateHt20_0; i <= rateHt20_7; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+			case 7: ratesArray[rateHt20_7] = txp_nh;
+			case 6: ratesArray[rateHt20_6] = txp_nh;
+			case 5: ratesArray[rateHt20_5] = txp_nh;
+			case 4: ratesArray[rateHt20_4] = txp_nh;
+			case 3: ratesArray[rateHt20_3] = txp_nh;
+			case 2: ratesArray[rateHt20_2] = txp_nh;
+			case 1: ratesArray[rateHt20_1] = txp_nh;
+			case 0: ratesArray[rateHt20_0] = txp_nh; break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = rateHt40_0; i <Ar5416RateSize ; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		// to-do: i don't know the meaning of "DupCck" and "ExtCck" 
+		// but seems that it's sth to do with CCK so i use txpower_b_high
+		// the same as "rateDupOfdm" and "rateExtOfdm"
+		ratesArray[rateDupCck] = txp_bh;
+		ratesArray[rateExtCck] = txp_bh;
+		ratesArray[rateDupOfdm] = txp_gh;
+		ratesArray[rateExtOfdm] = txp_gh;
+		
+		// print to dmesg
+		printk("ath: eeprom_4k: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: eeprom_4k: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: eeprom_4k: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+	}
+	
+	// debug: print ratesArray
+	if (common->txpower_debug) {
+		printk("ath: eeprom_4k: TX Power Debug: ratesArray[]: \n");
+		for (j=0; j<(Ar5416RateSize/8)+1; j++) {
+			for (i=0; i<8; i++) {
+				printk("%d ", ratesArray[j*8+i]);
+			}
+			printk("\n");
+		}
+	}
+	
 	ENABLE_REGWRITE_BUFFER(ah);
 
 	/* OFDM power per rate */
@@ -759,6 +854,7 @@ static void ath9k_hw_4k_set_board_values
 	struct modal_eep_4k_header *pModal;
 	struct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;
 	struct base_eep_header_4k *pBase = &eep->baseEepHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	u8 txRxAttenLocal;
 	u8 ob[5], db1[5], db2[5];
 	u8 ant_div_control1, ant_div_control2;
@@ -775,8 +871,16 @@ static void ath9k_hw_4k_set_board_values
 
 	/* Initialize Ant Diversity settings from EEPROM */
 	if (pModal->version >= 3) {
-		ant_div_control1 = pModal->antdiv_ctl1;
-		ant_div_control2 = pModal->antdiv_ctl2;
+		// Custom ant div setting
+		if (1 == common->ant_custom_en) {
+			ant_div_control1 = ((common->ant_div_ctl) & 0xF0) >>4; 
+			ant_div_control2 = (common->ant_div_ctl) & 0x0F;
+			printk("ath9k: eeprom_4k: ant_div custom enabled, ctl1: %d, ctl2: %d\n", ant_div_control1, ant_div_control2);
+		} else {
+			printk("ath9k: eeprom_4k: ant_div custom disabled - use eeprom value, ctl1: %d, ctl2: %d\n", pModal->antdiv_ctl1, pModal->antdiv_ctl2);
+			ant_div_control1 = pModal->antdiv_ctl1;
+			ant_div_control2 = pModal->antdiv_ctl2;
+		}
 
 		regVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);
 		regVal &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));
@@ -819,7 +923,7 @@ static void ath9k_hw_4k_set_board_values
 			regVal &= (~(AR_PHY_9285_FAST_DIV_BIAS));
 			regVal |= (0 << AR_PHY_9285_FAST_DIV_BIAS_S);
 			REG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);
-		}
+		}	
 	}
 
 	if (pModal->version >= 2) {
@@ -983,9 +1087,9 @@ static void ath9k_hw_4k_set_board_values
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,
 			      pModal->txEndToRxOn);
 	REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
-		      pModal->thresh62);
+		      thresh62_man);
 	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
-		      pModal->thresh62);
+		      thresh62_man);
 
 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,
--- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
@@ -18,6 +18,8 @@
 #include "hw.h"
 #include "ar9002_phy.h"
 
+extern u8 tx_power_man;
+
 #define SIZE_EEPROM_AR9287 (sizeof(struct ar9287_eeprom) / sizeof(u16))
 
 static int ath9k_hw_ar9287_get_eeprom_ver(struct ath_hw *ah)
@@ -711,9 +713,11 @@ static void ath9k_hw_ar9287_set_txpower(
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar9287_eeprom *pEepData = &ah->eeprom.map9287;
 	struct modal_eep_ar9287_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
-	int i;
+	int i, j;
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
 
 	memset(ratesArray, 0, sizeof(ratesArray));
 
@@ -740,10 +744,101 @@ static void ath9k_hw_ar9287_set_txpower(
 
 	if (test)
 		return;
-
+		
 	for (i = 0; i < Ar5416RateSize; i++)
 		ratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;
-
+	
+	
+	if (common->txpower_custom == 1) {
+		// Use custom txpower
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;
+		
+		// set 802.11b power
+		for (i = rate1l; i <= rateXr; i++) {
+			ratesArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			ratesArray[rate11l] = txp_bh;
+			ratesArray[rate11s] = txp_bh;
+		case 5:
+			ratesArray[rate5_5l] = txp_bh;
+			ratesArray[rate5_5s] = txp_bh;
+		case 2:
+			ratesArray[rate2l] = txp_bh;
+			ratesArray[rate2s] = txp_bh;
+		case 1:
+			ratesArray[rate1l] = txp_bh;
+			ratesArray[rateXr] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = rate6mb; i <= rate54mb; i++) {
+			ratesArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+			case 54: ratesArray[rate54mb] = txp_gh;
+			case 48: ratesArray[rate48mb] = txp_gh;
+			case 36: ratesArray[rate36mb] = txp_gh;
+			case 24: ratesArray[rate24mb] = txp_gh;
+			case 18: ratesArray[rate18mb] = txp_gh;
+			case 12: ratesArray[rate12mb] = txp_gh;
+			case 9: ratesArray[rate9mb]   = txp_gh;
+			case 6: ratesArray[rate6mb]   = txp_gh; break;
+		}
+	
+		// 802.11n HT20 power
+		for (i = rateHt20_0; i <= rateHt20_7; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+			case 7: ratesArray[rateHt20_7] = txp_nh;
+			case 6: ratesArray[rateHt20_6] = txp_nh;
+			case 5: ratesArray[rateHt20_5] = txp_nh;
+			case 4: ratesArray[rateHt20_4] = txp_nh;
+			case 3: ratesArray[rateHt20_3] = txp_nh;
+			case 2: ratesArray[rateHt20_2] = txp_nh;
+			case 1: ratesArray[rateHt20_1] = txp_nh;
+			case 0: ratesArray[rateHt20_0] = txp_nh; break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = rateHt40_0; i <Ar5416RateSize ; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		// to-do: i don't know the meaning of "DupCck" and "ExtCck" 
+		// but seems that it's sth to do with CCK so i use txpower_b_high
+		// the same as "rateDupOfdm" and "rateExtOfdm"
+		ratesArray[rateDupCck] = txp_bh;
+		ratesArray[rateExtCck] = txp_bh;
+		ratesArray[rateDupOfdm] = txp_gh;
+		ratesArray[rateExtOfdm] = txp_gh;
+		
+		// print to dmesg
+		printk("ath: eeprom_9287: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: eeprom_9287: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: eeprom_9287: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+	}
+	
+	// debug: print ratesArray
+	if (common->txpower_debug) {
+		printk("ath: eeprom_9287: TX Power Debug: ratesArray[]: \n");
+		for (j=0; j<(Ar5416RateSize/8)+1; j++) {
+			for (i=0; i<8; i++) {
+				printk("%d ", ratesArray[j*8+i]);
+			}
+			printk("\n");
+		}
+	}
+	
 	ENABLE_REGWRITE_BUFFER(ah);
 
 	/* OFDM power per rate */
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -37,6 +37,39 @@ MODULE_DESCRIPTION("Support for Atheros
 MODULE_SUPPORTED_DEVICE("Atheros 802.11n WLAN cards");
 MODULE_LICENSE("Dual BSD/GPL");
 
+u8 tx_power_man = 58; //manual power
+u8 cwmin_man = 7;
+u8 cwmax_man = 15;
+u8 aifs_man = 2;
+u8 cck_sifs_man = 10;
+u8 ofdm_sifs_man = 16;
+u8 slottime_man = 9;
+u8 thresh62_man = 28;
+
+module_param_named(txpower,tx_power_man,byte,0444);
+MODULE_PARM_DESC(txpower,"Manual TX power setting, default 58, max 63");
+
+module_param_named(cwmin,cwmin_man,byte,0444);
+MODULE_PARM_DESC(cwmin,"CWMIN setting, 0-255, default 7");
+
+module_param_named(cwmax,cwmax_man,byte,0444);
+MODULE_PARM_DESC(cwmax,"CWMAX setting, 0-255, default 15");
+
+module_param_named(aifs,aifs_man,byte,0444);
+MODULE_PARM_DESC(aifs,"AIFS setting, default 2");
+
+module_param_named(cck_sifs,cck_sifs_man,byte,0444);
+MODULE_PARM_DESC(cck_sifs,"CCK SIFS setting, default 10");
+
+module_param_named(ofdm_sifs,ofdm_sifs_man,byte,0444);
+MODULE_PARM_DESC(ofdm_sifs,"OFDM SIFS setting, default 16");
+
+module_param_named(slottime,slottime_man,byte,0444);
+MODULE_PARM_DESC(slottime,"Slottime setting, default 9");
+
+module_param_named(thresh62,thresh62_man,byte,0444);
+MODULE_PARM_DESC(thresh62,"CCA THRESH62 setting, default 28");
+
 static void ath9k_hw_set_clockrate(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -62,6 +95,13 @@ static void ath9k_hw_set_clockrate(struc
 			clockrate /= 2;
 		if (IS_CHAN_QUARTER_RATE(chan))
 			clockrate /= 4;
+		if (IS_CHAN_2M5_RATE(chan))
+                        clockrate /= 8;
+                if (IS_CHAN_12M5_RATE(chan))
+                        clockrate = (clockrate * 5) / 8;
+                if (IS_CHAN_7M_RATE(chan))
+                        clockrate = (((clockrate / 2)*5)/7);
+
 	}
 
 	common->clockrate = clockrate;
@@ -104,6 +144,12 @@ void ath9k_hw_synth_delay(struct ath_hw
 		hw_delay *= 2;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		hw_delay *= 4;
+	else if (IS_CHAN_2M5_RATE(chan))
+                hw_delay *= 8;
+	else if (IS_CHAN_12M5_RATE(chan))
+                hw_delay = (hw_delay *8)/5;
+	else if (IS_CHAN_7M_RATE(chan))
+                hw_delay = ((hw_delay *2)*7)/5;
 
 	udelay(hw_delay + BASE_ACTIVATE_DELAY);
 }
@@ -200,7 +246,34 @@ u16 ath9k_hw_computetxtime(struct ath_hw
 			txTime = OFDM_SIFS_TIME_HALF +
 				OFDM_PREAMBLE_TIME_HALF
 				+ (numSymbols * OFDM_SYMBOL_TIME_HALF);
-		} else {
+		} else if (ah->curchan &&
+                           IS_CHAN_2M5_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                ((kbps >> 3) * OFDM_SYMBOL_TIME_2M5) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_2M5 +
+                                OFDM_PREAMBLE_TIME_2M5
+                                + (numSymbols * OFDM_SYMBOL_TIME_2M5);
+                } else if (ah->curchan &&
+                           IS_CHAN_7M_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                (( ((kbps>>1) *5)/7) * OFDM_SYMBOL_TIME_7M) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_7M +
+                                OFDM_PREAMBLE_TIME_7M
+                                + (numSymbols * OFDM_SYMBOL_TIME_7M);
+                } else if (ah->curchan &&
+                           IS_CHAN_12M5_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                (((kbps*5)/8) * OFDM_SYMBOL_TIME_12M5) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_12M5 +
+                                OFDM_PREAMBLE_TIME_12M5
+                                + (numSymbols * OFDM_SYMBOL_TIME_12M5);
+                } else {
 			bitsPerSymbol = (kbps * OFDM_SYMBOL_TIME) / 1000;
 			numBits = OFDM_PLCP_BITS + (frameLen << 3);
 			numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
@@ -1092,7 +1165,44 @@ void ath9k_hw_init_global_settings(struc
 		ack_offset = 32;
 		ack_shift = 1;
 		slottime = 21;
-	} else {
+	} else if (IS_CHAN_2M5_RATE(chan)) {
+		// Note: I don't know how to set these args
+		// just *2 and hope it will work
+		eifs = 680;	
+		rx_lat = (rx_lat * 8) - 1;
+		tx_lat *= 8;
+		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+		    tx_lat += 44;
+
+		sifstime = 128;
+		ack_offset = 64;
+		ack_shift = 0;	// see ar9271 datasheet - 2M5 chanbw when ACK_SHIFT=0
+		slottime = 36;	// hope it will work
+	} else if (IS_CHAN_12M5_RATE(chan)) {
+                // Note: I don't know how to set these args
+                eifs = 140;
+                rx_lat = ((rx_lat * 8) / 5) - 1;
+                tx_lat = (tx_lat *8) / 5;
+                if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+                    tx_lat += 8;
+
+                sifstime = 25;
+                ack_offset = 12;
+                ack_shift = 3;
+                slottime = 10;
+        } else if (IS_CHAN_7M_RATE(chan)) {
+                // Note: I don't know how to set these args
+                eifs = 250;
+                rx_lat = ((rx_lat * 14)/5) - 1;
+                tx_lat = ((tx_lat * 14) /5);
+                if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+                    tx_lat += 18;
+
+                sifstime = 45;
+                ack_offset = 23;
+                ack_shift = 1;
+                slottime = 18;
+        } else {
 		if (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {
 			eifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;
 			reg = AR_USEC_ASYNC_FIFO;
@@ -1108,7 +1218,7 @@ void ath9k_hw_init_global_settings(struc
 	}
 
 	/* As defined by IEEE 802.11-2007 17.3.8.6 */
-	slottime += 3 * ah->coverage_class;
+	slottime = slottime_man;
 	acktimeout = slottime + sifstime + ack_offset;
 	ctstimeout = acktimeout;
 
@@ -1120,7 +1230,9 @@ void ath9k_hw_init_global_settings(struc
 	 * timeout issues in other cases as well.
 	 */
 	if (IS_CHAN_2GHZ(chan) &&
-	    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {
+	    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)
+		&& !IS_CHAN_12M5_RATE(chan) && !IS_CHAN_7M_RATE(chan)
+		&& !IS_CHAN_2M5_RATE(chan)) {
 		acktimeout += 64 - sifstime - ah->slottime;
 		ctstimeout += 48 - sifstime - ah->slottime;
 	}
@@ -1147,7 +1259,9 @@ void ath9k_hw_init_global_settings(struc
 		SM(tx_lat, AR_USEC_TX_LAT),
 		AR_USEC_TX_LAT | AR_USEC_RX_LAT | AR_USEC_USEC);
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan) 
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_7M_RATE(chan)
+		|| IS_CHAN_12M5_RATE(chan) )
 		REG_RMW(ah, AR_TXSIFS,
 			sifstime | SM(ack_shift, AR_TXSIFS_ACK_SHIFT),
 			(AR_TXSIFS_TIME | AR_TXSIFS_ACK_SHIFT));
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -74,7 +74,7 @@
 
 #define ATH9K_RSSI_BAD			-128
 
-#define ATH9K_NUM_CHANNELS	38
+#define ATH9K_NUM_CHANNELS	85
 
 /* Register read/write primitives */
 #define REG_WRITE(_ah, _reg, _val) \
@@ -459,10 +459,16 @@ struct ath9k_channel {
 #define CHANNEL_HT		BIT(3)
 #define CHANNEL_HT40PLUS	BIT(4)
 #define CHANNEL_HT40MINUS	BIT(5)
+#define CHANNEL_2M5		BIT(6)
+#define CHANNEL_7M		BIT(7)
+#define CHANNEL_12M5		BIT(8)
 
 #define IS_CHAN_5GHZ(_c) (!!((_c)->channelFlags & CHANNEL_5GHZ))
 #define IS_CHAN_2GHZ(_c) (!IS_CHAN_5GHZ(_c))
 
+#define IS_CHAN_2M5_RATE(_c) (!!((_c)->channelFlags & CHANNEL_2M5))
+#define IS_CHAN_7M_RATE(_c) (!!((_c)->channelFlags & CHANNEL_7M))
+#define IS_CHAN_12M5_RATE(_c) (!!((_c)->channelFlags & CHANNEL_12M5))
 #define IS_CHAN_HALF_RATE(_c) (!!((_c)->channelFlags & CHANNEL_HALF))
 #define IS_CHAN_QUARTER_RATE(_c) (!!((_c)->channelFlags & CHANNEL_QUARTER))
 #define IS_CHAN_A_FAST_CLOCK(_ah, _c)			\
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -18,6 +18,12 @@
 #include "hw-ops.h"
 #include <linux/export.h>
 
+extern u8 cwmin_man;
+extern u8 cwmax_man;
+extern u8 aifs_man;
+extern u8 cck_sifs;
+extern u8 ofdm_sifs;
+
 static void ath9k_hw_set_txq_interrupts(struct ath_hw *ah,
 					struct ath9k_tx_queue_info *qi)
 {
@@ -141,6 +147,13 @@ void ath9k_hw_abort_tx_dma(struct ath_hw
 			maxdelay *= 2;
 		else if (IS_CHAN_QUARTER_RATE(ah->curchan))
 			maxdelay *= 4;
+		else if (IS_CHAN_2M5_RATE(ah->curchan))
+			maxdelay *= 8;
+		else if (IS_CHAN_12M5_RATE(ah->curchan))
+                        maxdelay = (maxdelay *8)/5;
+		else if (IS_CHAN_7M_RATE(ah->curchan))
+                        maxdelay = (maxdelay *14) /5;
+
 	}
 
 	REG_WRITE(ah, AR_Q_TXD, AR_Q_TXD_M);
@@ -216,7 +229,7 @@ bool ath9k_hw_set_txq_props(struct ath_h
 	if (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT)
 		qi->tqi_aifs = min(qinfo->tqi_aifs, 255U);
 	else
-		qi->tqi_aifs = INIT_AIFS;
+		qi->tqi_aifs = aifs_man;
 	if (qinfo->tqi_cwmin != ATH9K_TXQ_USEDEFAULT) {
 		cw = min(qinfo->tqi_cwmin, 1024U);
 		qi->tqi_cwmin = 1;
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -34,14 +34,11 @@ static struct reg_dmn_pair_mapping *ath_
  */
 
 /* Only these channels all allow active scan on all world regulatory domains */
-#define ATH9K_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define ATH9K_2GHZ_CH01_11	REG_RULE(2292-10, 2462+10, 40, 0, 30, 0)
 
 /* We enable active scan on these a case by case basis by regulatory domain */
-#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR)
-#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR | \
-					 NL80211_RRF_NO_OFDM)
+#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 30, 0)
+#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2732+10, 40, 0, 30, 0)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
 #define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
@@ -81,9 +78,8 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	)
 };
 
@@ -91,8 +87,8 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	)
 };
 
@@ -100,7 +96,7 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	)
 };
@@ -109,8 +105,7 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	)
 };
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -223,15 +223,12 @@ static const struct ieee80211_regdomain
 	.alpha2 =  "00",
 	.reg_rules = {
 		/* IEEE 802.11b/g, channels 1..11 */
-		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
+		REG_RULE(2292-10, 2462+10, 40, 6, 30, 0),
 		/* IEEE 802.11b/g, channels 12..13. */
-		REG_RULE(2467-10, 2472+10, 20, 6, 20,
-			NL80211_RRF_NO_IR | NL80211_RRF_AUTO_BW),
+		REG_RULE(2467-10, 2472+10, 40, 6, 30, 0),
 		/* IEEE 802.11 channel 14 - Only JP enables
 		 * this and for 802.11b only */
-		REG_RULE(2484-10, 2484+10, 20, 6, 20,
-			NL80211_RRF_NO_IR |
-			NL80211_RRF_NO_OFDM),
+		REG_RULE(2484-10, 2732+10, 40, 6, 30, 0),
 		/* IEEE 802.11a, channel 36..48 */
 		REG_RULE(5180-10, 5240+10, 80, 6, 20,
                         NL80211_RRF_NO_IR |
@@ -3383,13 +3380,6 @@ static int reg_set_rd_user(const struct
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	if (!user_request->intersect) {
 		reset_regdomains(false, rd);
 		return 0;
@@ -3420,13 +3410,6 @@ static int reg_set_rd_driver(const struc
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	request_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);
 	if (!request_wiphy)
 		return -ENODEV;
@@ -3479,13 +3462,6 @@ static int reg_set_rd_country_ie(const s
 	 * and the pending request came in from a country IE
 	 */
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	request_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);
 	if (!request_wiphy)
 		return -ENODEV;
@@ -3584,11 +3560,6 @@ static int __regulatory_set_wiphy_regd(s
 		 "wiphy should have REGULATORY_WIPHY_SELF_MANAGED\n"))
 		return -EPERM;
 
-	if (WARN(!is_valid_rd(rd), "Invalid regulatory domain detected\n")) {
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	regd = reg_copy_regd(rd);
 	if (IS_ERR(regd))
 		return PTR_ERR(regd);
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -76,10 +76,16 @@ int ieee80211_channel_to_frequency(int c
 		return 0; /* not supported */
 	switch (band) {
 	case NL80211_BAND_2GHZ:
-		if (chan == 14)
+		if (chan == 16)
 			return 2484;
-		else if (chan < 14)
+		else if (chan == 255)
+			return 2407;
+		else if (chan > 0 && chan < 16)
 			return 2407 + chan * 5;
+		else if (chan > 16 && chan < 127)
+			return (2407 - 5) + chan * 5; 
+		else if (chan > 127 && chan < 255)
+			return 2407 - (255 - chan) * 5;
 		break;
 	case NL80211_BAND_5GHZ:
 		if (chan >= 182 && chan <= 196)
@@ -102,9 +108,15 @@ int ieee80211_frequency_to_channel(int f
 {
 	/* see 802.11 17.3.8.3.2 and Annex J */
 	if (freq == 2484)
-		return 14;
-	else if (freq < 2484)
+		return 16;
+	else if (freq == 2407)
+		return 255;
+	else if (freq > 2407 && freq < 2484)
 		return (freq - 2407) / 5;
+	else if (freq > 2000 && freq < 2407)
+		return 255 - ((2407 - freq) / 5);
+	else if (freq > 2484 && freq < 3000)
+		return (freq - 2402) / 5;
 	else if (freq >= 4910 && freq <= 4980)
 		return (freq - 4000) / 5;
 	else if (freq <= 45000) /* DMG band lower limit */
@@ -1464,7 +1476,7 @@ bool ieee80211_chandef_to_operating_clas
 	u8 vht_opclass;
 	u32 freq = chandef->center_freq1;
 
-	if (freq >= 2412 && freq <= 2472) {
+	if (freq >= 2292 && freq <= 2732) {
 		if (chandef->width > NL80211_CHAN_WIDTH_40)
 			return false;
 
--- a/drivers/net/wireless/ath/ath9k/common.c
+++ b/drivers/net/wireless/ath/ath9k/common.c
@@ -184,6 +184,12 @@ int ath9k_cmn_process_rate(struct ath_co
 		rxs->bw = RATE_INFO_BW_5;
 	else if (IS_CHAN_HALF_RATE(ah->curchan))
 		rxs->bw = RATE_INFO_BW_10;
+	else if (IS_CHAN_2M5_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_2M5;
+	else if (IS_CHAN_12M5_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_12M5;
+	else if (IS_CHAN_7M_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_7M;
 
 	if (rx_stats->rs_rate & 0x80) {
 		/* HT rate */
@@ -312,6 +318,9 @@ static void ath9k_cmn_update_ichannel(st
 		flags |= CHANNEL_5GHZ;
 
 	switch (common->chan_bw) {
+	case 2:
+		width = NL80211_CHAN_WIDTH_2M5;
+		break;
 	case 5:
 		width = NL80211_CHAN_WIDTH_5;
 		break;
@@ -324,6 +333,9 @@ static void ath9k_cmn_update_ichannel(st
 	}
 
 	switch (width) {
+	case NL80211_CHAN_WIDTH_2M5:
+		flags |= CHANNEL_2M5;
+		break;
 	case NL80211_CHAN_WIDTH_5:
 		flags |= CHANNEL_QUARTER;
 		break;
--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
@@ -398,6 +398,50 @@ static const struct file_operations fops
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_chanbw(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath9k_htc_priv *priv = file->private_data;
+	struct ath_common *common = ath9k_hw_common(priv->ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chanbw(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath9k_htc_priv *priv = file->private_data;
+	struct ath_common *common = ath9k_hw_common(priv->ah);
+	unsigned long chan_bw;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &chan_bw))
+		return -EINVAL;
+
+	common->chan_bw = chan_bw;
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_htc_ops.config(priv->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanbw = {
+	.read = read_file_chanbw,
+	.write = write_file_chanbw,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 /* Ethtool support for get-stats */
 #define AMKSTR(nm) #nm "_BE", #nm "_BK", #nm "_VI", #nm "_VO"
 static const char ath9k_htc_gstrings_stats[][ETH_GSTRING_LEN] = {
@@ -516,6 +560,8 @@ int ath9k_htc_init_debug(struct ath_hw *
 			    priv, &fops_queue);
 	debugfs_create_file("debug", 0600, priv->debug.debugfs_phy,
 			    priv, &fops_debug);
+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, priv->debug.debugfs_phy,
+			    priv, &fops_chanbw);
 
 	ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
 	ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -4073,6 +4073,7 @@ enum nl80211_channel_type {
  *	attribute must be provided as well
  * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
  * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_2M5: 2.5 MHz OFDM channel
  */
 enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_20_NOHT,
@@ -4083,6 +4084,7 @@ enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_160,
 	NL80211_CHAN_WIDTH_5,
 	NL80211_CHAN_WIDTH_10,
+	NL80211_CHAN_WIDTH_2M5,
 };
 
 /**
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -845,6 +845,12 @@ static void ar5008_hw_set_delta_slope(st
 		clockMhzScaled = clockMhzScaled >> 1;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		clockMhzScaled = clockMhzScaled >> 2;
+	else if (IS_CHAN_2M5_RATE(chan))
+		clockMhzScaled = clockMhzScaled >> 3;
+	else if (IS_CHAN_7M_RATE(chan))
+		clockMhzScaled = (clockMhzScaled*5) / 14;
+	else if (IS_CHAN_12M5_RATE(chan))
+		clockMhzScaled = (clockMhzScaled*5) / 8;
 
 	ath9k_hw_get_channel_centers(ah, chan, &centers);
 	coef_scaled = clockMhzScaled / centers.synth_center;
@@ -905,6 +911,18 @@ static u32 ar9160_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_7M_RATE(chan)) {
+		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0x8, AR_RTC_9160_PLL_REFDIV);
+	}
 
 	if (chan && IS_CHAN_5GHZ(chan))
 		pll |= SM(0x50, AR_RTC_9160_PLL_DIV);
@@ -921,10 +939,17 @@ static u32 ar5008_hw_compute_pll_control
 
 	pll = AR_RTC_PLL_REFDIV_5 | AR_RTC_PLL_DIV2;
 
-	if (chan && IS_CHAN_HALF_RATE(chan))
+	if (chan && (IS_CHAN_HALF_RATE(chan) || IS_CHAN_7M_RATE(chan) 
+		|| IS_CHAN_12M5_RATE(chan)))
 		pll |= SM(0x1, AR_RTC_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan))
+                pll |= SM(0x2, AR_RTC_PLL_CLKSEL);
+
+	// seems that we can't set ar5008 ref_div to 10? 
+	// set 2m5 to 5, 7m/12m5 to 10m
+	// needs test
 
 	if (chan && IS_CHAN_5GHZ(chan))
 		pll |= SM(0xa, AR_RTC_PLL_DIV);
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.c
@@ -111,7 +111,11 @@ static int ar9002_hw_set_channel(struct
 
 		switch (ah->eep_ops->get_eeprom(ah, EEP_FRAC_N_5G)) {
 		case 0:
-			if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+			if (IS_CHAN_HALF_RATE(chan) || 
+				IS_CHAN_QUARTER_RATE(chan) || 
+				IS_CHAN_2M5_RATE(chan) ||
+				IS_CHAN_7M_RATE(chan) || 
+                                IS_CHAN_12M5_RATE(chan) )
 				aModeRefSel = 0;
 			else if ((freq % 20) == 0)
 				aModeRefSel = 3;
@@ -324,7 +328,22 @@ static u32 ar9002_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
-
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+		// Note: experimental, needs test
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+                // Note: experimental, needs test
+                pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9160_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
+                // Note: experimental, needs test
+                pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9160_PLL_REFDIV);
+        }
 	return pll;
 }
 
--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
@@ -1451,7 +1451,9 @@ static bool ar9003_hw_init_cal_pcoem(str
 		}
 	}
 
-	if ((IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)) ||
+	if ((IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)
+		|| IS_CHAN_2M5_RATE(chan)) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan)
 	    !(ah->enabled_cals & TX_IQ_CAL))
 		goto skip_tx_iqcal;
 
@@ -1596,7 +1598,9 @@ static bool ar9003_hw_init_cal_soc(struc
 		run_agc_cal = true;
 	}
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan))
 		goto skip_tx_iqcal;
 
 	/* Do Tx IQ Calibration */
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -597,7 +597,19 @@ static u32 ar9003_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9300_SOC_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);
-
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9300_SOC_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);             // need$
+                pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9300_SOC_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9300_SOC_PLL_CLKSEL);             // need$
+                pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9300_SOC_PLL_REFDIV);
+        }
 	pll |= SM(0x2c, AR_RTC_9300_SOC_PLL_DIV_INT);
 
 	return pll;
@@ -614,6 +626,19 @@ static u32 ar9003_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9300_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9300_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9300_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9300_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9300_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x3, AR_RTC_9300_PLL_CLKSEL);         // needs test
+                pll &= (~(AR_RTC_9300_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9300_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9300_PLL_CLKSEL);         // needs test
+                pll &= (~(AR_RTC_9300_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9300_PLL_REFDIV);
+        }
 
 	pll |= SM(0x2c, AR_RTC_9300_PLL_DIV);
 
@@ -996,7 +1021,9 @@ static void ar9003_hw_set_rfmode(struct
 	if (IS_CHAN_A_FAST_CLOCK(ah, chan))
 		rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan) 
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan) )
 		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
 			      AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW, 3);
 
@@ -1023,6 +1050,12 @@ static void ar9003_hw_set_delta_slope(st
 		clockMhzScaled = clockMhzScaled >> 1;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		clockMhzScaled = clockMhzScaled >> 2;
+	else if (IS_CHAN_2M5_RATE(chan))
+                clockMhzScaled = clockMhzScaled >> 3;
+	else if (IS_CHAN_12M5_RATE(chan))
+                clockMhzScaled = (clockMhzScaled*5) / 8;
+	else if (IS_CHAN_7M_RATE(chan))
+                clockMhzScaled = (clockMhzScaled*5) / 14;
 
 	/*
 	 * ALGO -> coef = 1e8/fcarrier*fclock/40;
--- a/drivers/net/wireless/ath/ath9k/dynack.c
+++ b/drivers/net/wireless/ath/ath9k/dynack.c
@@ -53,6 +53,12 @@ static inline u32 ath_dynack_get_sifs(st
 			sifs = OFDM_SIFS_TIME_QUARTER;
 		else if (IS_CHAN_HALF_RATE(ah->curchan))
 			sifs = OFDM_SIFS_TIME_HALF;
+		else if (IS_CHAN_2M5_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_2M5;
+		else if (IS_CHAN_12M5_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_12M5;
+		else if (IS_CHAN_7M_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_7M;
 		else
 			sifs = OFDM_SIFS_TIME;
 	}
--- a/drivers/net/wireless/ath/ath9k/mac.h
+++ b/drivers/net/wireless/ath/ath9k/mac.h
@@ -57,6 +57,21 @@
 #define OFDM_PLCP_BITS_QUARTER      22
 #define OFDM_SYMBOL_TIME_QUARTER    16
 
+#define OFDM_SIFS_TIME_2M5     	128
+#define OFDM_PREAMBLE_TIME_2M5  160
+#define OFDM_PLCP_BITS_2M5      22
+#define OFDM_SYMBOL_TIME_2M5    32
+
+#define OFDM_SIFS_TIME_12M5      25
+#define OFDM_PREAMBLE_TIME_12M5  32
+#define OFDM_PLCP_BITS_12M5      22
+#define OFDM_SYMBOL_TIME_12M5    7
+
+#define OFDM_SIFS_TIME_7M      46
+#define OFDM_PREAMBLE_TIME_7M  57
+#define OFDM_PLCP_BITS_7M      22
+#define OFDM_SYMBOL_TIME_7M    12
+
 #define INIT_AIFS       2
 #define INIT_CWMIN      15
 #define INIT_CWMIN_11B  31
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -1108,7 +1108,10 @@ enum rate_info_flags {
  *
  * Used by the driver to indicate the rate bandwidth.
  *
+ * @RATE_INFO_BW_2M5: 2.5 MHz bandwidth
  * @RATE_INFO_BW_5: 5 MHz bandwidth
+ * @RATE_INFO_BW_7M: 7 MHz bandwidth
+ * @RATE_INFO_BW_12M5: 12.5 MHz bandwidth
  * @RATE_INFO_BW_10: 10 MHz bandwidth
  * @RATE_INFO_BW_20: 20 MHz bandwidth
  * @RATE_INFO_BW_40: 40 MHz bandwidth
@@ -1124,6 +1127,9 @@ enum rate_info_bw {
 	RATE_INFO_BW_80,
 	RATE_INFO_BW_160,
 	RATE_INFO_BW_HE_RU,
+	RATE_INFO_BW_2M5,
+	RATE_INFO_BW_7M,
+	RATE_INFO_BW_12M5,
 };
 
 /**
