--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -150,6 +150,7 @@ struct ath_common {
 	enum ath_device_state state;
 	unsigned long op_flags;
 	u32 chan_bw;
+	u8 txpower_man;
 
 	struct ath_ani ani;
 
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -5255,6 +5255,12 @@ static void ar9003_hw_set_power_per_rate
 	ath9k_hw_get_channel_centers(ah, chan, &centers);
 	scaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,
 						antenna_reduction);
+										
+	for (i = 0; i < ar9300RateSize; i++)
+		pPwrArray[i] = common->txpower_man;
+	
+	printk("ath: ar9003_eeprom: TX Power set: %d\n", common->txpower_man);	
+	return;
 
 	if (is2ghz) {
 		/* Setup for CTL modes */
--- a/drivers/net/wireless/ath/ath9k/common-init.c
+++ b/drivers/net/wireless/ath/ath9k/common-init.c
@@ -22,7 +22,7 @@
 	.band = NL80211_BAND_2GHZ, \
 	.center_freq = (_freq), \
 	.hw_value = (_idx), \
-	.max_power = 20, \
+	.max_power = 30, \
 }
 
 #define CHAN5G(_freq, _idx) { \
@@ -36,7 +36,30 @@
  * on 5 MHz steps, we support the channels which we know
  * we have calibration data for all cards though to make
  * this static */
-static const struct ieee80211_channel ath9k_2ghz_chantable[] = {
+static const struct ieee80211_channel ath9k_2ghz_chantable[] = {	
+	// 61 Channels 2.3G~2.5G
+	CHAN2G(2302, 39), /* Channel XX */
+	CHAN2G(2307, 40), /* Channel XX */
+	CHAN2G(2312, 41), /* Channel XX */
+	CHAN2G(2317, 42), /* Channel XX */
+	CHAN2G(2322, 43), /* Channel XX */
+	CHAN2G(2327, 44), /* Channel XX */
+	CHAN2G(2332, 45), /* Channel XX */
+	CHAN2G(2337, 46), /* Channel XX */
+	CHAN2G(2342, 47), /* Channel XX */
+	CHAN2G(2347, 48), /* Channel XX */
+	CHAN2G(2352, 49), /* Channel XX */
+	CHAN2G(2357, 50), /* Channel XX */
+	CHAN2G(2362, 51), /* Channel XX */
+	CHAN2G(2367, 52), /* Channel XX */
+	CHAN2G(2372, 53), /* Channel XX */
+	CHAN2G(2377, 54), /* Channel XX */
+	CHAN2G(2382, 55), /* Channel XX */
+	CHAN2G(2387, 56), /* Channel XX */
+	CHAN2G(2392, 57), /* Channel XX */
+	CHAN2G(2397, 58), /* Channel XX */
+	CHAN2G(2402, 59), /* Channel XX */
+	CHAN2G(2407, 60), /* Channel XX */
 	CHAN2G(2412, 0), /* Channel 1 */
 	CHAN2G(2417, 1), /* Channel 2 */
 	CHAN2G(2422, 2), /* Channel 3 */
@@ -49,8 +72,33 @@ static const struct ieee80211_channel at
 	CHAN2G(2457, 9), /* Channel 10 */
 	CHAN2G(2462, 10), /* Channel 11 */
 	CHAN2G(2467, 11), /* Channel 12 */
-	CHAN2G(2472, 12), /* Channel 13 */
-	CHAN2G(2484, 13), /* Channel 14 */
+	CHAN2G(2472, 12), /* Channel XX */
+	CHAN2G(2477, 13), /* Channel XX */
+	CHAN2G(2482, 14), /* Channel XX */
+	CHAN2G(2484, 15), /* Channel XX */	// JP Compatible
+	CHAN2G(2487, 16), /* Channel XX */
+	CHAN2G(2492, 17), /* Channel XX */
+	CHAN2G(2497, 18), /* Channel XX */
+	CHAN2G(2502, 19), /* Channel XX */
+	CHAN2G(2507, 20), /* Channel XX */
+	CHAN2G(2512, 21), /* Channel XX */
+	CHAN2G(2517, 22), /* Channel XX */
+	CHAN2G(2522, 23), /* Channel XX */
+	CHAN2G(2527, 24), /* Channel XX */
+	CHAN2G(2532, 25), /* Channel XX */
+	CHAN2G(2537, 26), /* Channel XX */
+	CHAN2G(2542, 27), /* Channel XX */
+	CHAN2G(2547, 28), /* Channel XX */
+	CHAN2G(2552, 29), /* Channel XX */
+	CHAN2G(2557, 30), /* Channel XX */
+	CHAN2G(2562, 31), /* Channel XX */
+	CHAN2G(2567, 32), /* Channel XX */
+	CHAN2G(2572, 33), /* Channel XX */
+	CHAN2G(2577, 34), /* Channel XX */
+	CHAN2G(2582, 35), /* Channel XX */
+	CHAN2G(2587, 36), /* Channel XX */
+	CHAN2G(2592, 37), /* Channel XX */
+	CHAN2G(2597, 38), /* Channel XX */
 };
 
 /* Some 5 GHz radios are actually tunable on XXXX-YYYY
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -1565,6 +1565,51 @@ static const struct file_operations fops
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_txpower_man(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "%d\n", common->txpower_man);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_txpower_man(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	u8 txpower;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtou8(buf, 0, &txpower))
+		return -EINVAL;
+
+	common->txpower_man = txpower;
+	
+	mutex_lock(&sc->mutex);
+	ath9k_set_txpower(sc, NULL);
+	mutex_unlock(&sc->mutex);
+
+	return count;
+}
+
+static const struct file_operations fops_txpower_man = {
+	.read = read_file_txpower_man,
+	.write = write_file_txpower_man,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -1663,6 +1708,8 @@ int ath9k_init_debug(struct ath_hw *ah)
 
 	debugfs_create_file("nf_override", 0600,
 			    sc->debug.debugfs_phy, sc, &fops_nf_override);
-
+				
+	debugfs_create_file("txpower_man", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_txpower_man);
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
@@ -18,6 +18,9 @@
 #include "hw.h"
 #include "ar9002_phy.h"
 
+extern u8 tx_power_man;
+extern u8 thresh62_man;
+
 static int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)
 {
 	u16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);
@@ -582,6 +585,7 @@ static void ath9k_hw_4k_set_txpower(stru
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;
 	struct modal_eep_4k_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
 	int i;
@@ -611,7 +615,9 @@ static void ath9k_hw_4k_set_txpower(stru
 	    return;
 
 	for (i = 0; i < Ar5416RateSize; i++)
-		ratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;
+		ratesArray[i] = common->txpower_man;
+	
+	printk("ath: eeprom_4k: TX Power set: %d\n", common->txpower_man);	
 
 	ENABLE_REGWRITE_BUFFER(ah);
 
@@ -983,9 +989,9 @@ static void ath9k_hw_4k_set_board_values
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,
 			      pModal->txEndToRxOn);
 	REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
-		      pModal->thresh62);
+		      thresh62_man);
 	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
-		      pModal->thresh62);
+		      thresh62_man);
 
 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,
--- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
@@ -18,6 +18,8 @@
 #include "hw.h"
 #include "ar9002_phy.h"
 
+extern u8 tx_power_man;
+
 #define SIZE_EEPROM_AR9287 (sizeof(struct ar9287_eeprom) / sizeof(u16))
 
 static int ath9k_hw_ar9287_get_eeprom_ver(struct ath_hw *ah)
@@ -711,6 +713,7 @@ static void ath9k_hw_ar9287_set_txpower(
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar9287_eeprom *pEepData = &ah->eeprom.map9287;
 	struct modal_eep_ar9287_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
 	int i;
@@ -742,7 +745,9 @@ static void ath9k_hw_ar9287_set_txpower(
 		return;
 
 	for (i = 0; i < Ar5416RateSize; i++)
-		ratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;
+		ratesArray[i] = common->txpower_man;
+	
+	printk("ath: eeprom_9287: TX Power set: %d\n", common->txpower_man);
 
 	ENABLE_REGWRITE_BUFFER(ah);
 
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -37,6 +37,39 @@ MODULE_DESCRIPTION("Support for Atheros
 MODULE_SUPPORTED_DEVICE("Atheros 802.11n WLAN cards");
 MODULE_LICENSE("Dual BSD/GPL");
 
+u8 tx_power_man = 58; //manual power
+u8 cwmin_man = 7;
+u8 cwmax_man = 15;
+u8 aifs_man = 2;
+u8 cck_sifs_man = 10;
+u8 ofdm_sifs_man = 16;
+u8 slottime_man = 9;
+u8 thresh62_man = 28;
+
+module_param_named(txpower,tx_power_man,byte,0444);
+MODULE_PARM_DESC(txpower,"Manual TX power setting, default 58, max 63");
+
+module_param_named(cwmin,cwmin_man,byte,0444);
+MODULE_PARM_DESC(cwmin,"CWMIN setting, 0-255, default 7");
+
+module_param_named(cwmax,cwmax_man,byte,0444);
+MODULE_PARM_DESC(cwmax,"CWMAX setting, 0-255, default 15");
+
+module_param_named(aifs,aifs_man,byte,0444);
+MODULE_PARM_DESC(aifs,"AIFS setting, default 2");
+
+module_param_named(cck_sifs,cck_sifs_man,byte,0444);
+MODULE_PARM_DESC(cck_sifs,"CCK SIFS setting, default 10");
+
+module_param_named(ofdm_sifs,ofdm_sifs_man,byte,0444);
+MODULE_PARM_DESC(ofdm_sifs,"OFDM SIFS setting, default 16");
+
+module_param_named(slottime,slottime_man,byte,0444);
+MODULE_PARM_DESC(slottime,"Slottime setting, default 9");
+
+module_param_named(thresh62,thresh62_man,byte,0444);
+MODULE_PARM_DESC(thresh62,"CCA THRESH62 setting, default 28");
+
 static void ath9k_hw_set_clockrate(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -1108,7 +1141,7 @@ void ath9k_hw_init_global_settings(struc
 	}
 
 	/* As defined by IEEE 802.11-2007 17.3.8.6 */
-	slottime += 3 * ah->coverage_class;
+	slottime = slottime_man;
 	acktimeout = slottime + sifstime + ack_offset;
 	ctstimeout = acktimeout;
 
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -74,7 +74,7 @@
 
 #define ATH9K_RSSI_BAD			-128
 
-#define ATH9K_NUM_CHANNELS	38
+#define ATH9K_NUM_CHANNELS	85
 
 /* Register read/write primitives */
 #define REG_WRITE(_ah, _reg, _val) \
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -18,6 +18,12 @@
 #include "hw-ops.h"
 #include <linux/export.h>
 
+extern u8 cwmin_man;
+extern u8 cwmax_man;
+extern u8 aifs_man;
+extern u8 cck_sifs;
+extern u8 ofdm_sifs;
+
 static void ath9k_hw_set_txq_interrupts(struct ath_hw *ah,
 					struct ath9k_tx_queue_info *qi)
 {
@@ -216,7 +222,7 @@ bool ath9k_hw_set_txq_props(struct ath_h
 	if (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT)
 		qi->tqi_aifs = min(qinfo->tqi_aifs, 255U);
 	else
-		qi->tqi_aifs = INIT_AIFS;
+		qi->tqi_aifs = aifs_man;
 	if (qinfo->tqi_cwmin != ATH9K_TXQ_USEDEFAULT) {
 		cw = min(qinfo->tqi_cwmin, 1024U);
 		qi->tqi_cwmin = 1;
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -34,14 +34,11 @@ static struct reg_dmn_pair_mapping *ath_
  */
 
 /* Only these channels all allow active scan on all world regulatory domains */
-#define ATH9K_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define ATH9K_2GHZ_CH01_11	REG_RULE(2292-10, 2462+10, 40, 0, 30, 0)
 
 /* We enable active scan on these a case by case basis by regulatory domain */
-#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR)
-#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR | \
-					 NL80211_RRF_NO_OFDM)
+#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 30, 0)
+#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2732+10, 40, 0, 30, 0)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
 #define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
@@ -81,9 +78,8 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	)
 };
 
@@ -91,8 +87,8 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	)
 };
 
@@ -100,7 +96,7 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	)
 };
@@ -109,8 +105,7 @@ static const struct ieee80211_regdomain
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
 	.alpha2 =  "99",
 	REGD_RULES(
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	)
 };
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -223,15 +223,12 @@ static const struct ieee80211_regdomain
 	.alpha2 =  "00",
 	.reg_rules = {
 		/* IEEE 802.11b/g, channels 1..11 */
-		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
+		REG_RULE(2292-10, 2462+10, 40, 6, 30, 0),
 		/* IEEE 802.11b/g, channels 12..13. */
-		REG_RULE(2467-10, 2472+10, 20, 6, 20,
-			NL80211_RRF_NO_IR | NL80211_RRF_AUTO_BW),
+		REG_RULE(2467-10, 2472+10, 40, 6, 30, 0),
 		/* IEEE 802.11 channel 14 - Only JP enables
 		 * this and for 802.11b only */
-		REG_RULE(2484-10, 2484+10, 20, 6, 20,
-			NL80211_RRF_NO_IR |
-			NL80211_RRF_NO_OFDM),
+		REG_RULE(2484-10, 2732+10, 40, 6, 30, 0),
 		/* IEEE 802.11a, channel 36..48 */
 		REG_RULE(5180-10, 5240+10, 80, 6, 20,
                         NL80211_RRF_NO_IR |
@@ -3383,13 +3380,6 @@ static int reg_set_rd_user(const struct
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	if (!user_request->intersect) {
 		reset_regdomains(false, rd);
 		return 0;
@@ -3420,13 +3410,6 @@ static int reg_set_rd_driver(const struc
 	if (!regdom_changes(rd->alpha2))
 		return -EALREADY;
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	request_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);
 	if (!request_wiphy)
 		return -ENODEV;
@@ -3479,13 +3462,6 @@ static int reg_set_rd_country_ie(const s
 	 * and the pending request came in from a country IE
 	 */
 
-	if (!is_valid_rd(rd)) {
-		pr_err("Invalid regulatory domain detected: %c%c\n",
-		       rd->alpha2[0], rd->alpha2[1]);
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	request_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);
 	if (!request_wiphy)
 		return -ENODEV;
@@ -3584,11 +3560,6 @@ static int __regulatory_set_wiphy_regd(s
 		 "wiphy should have REGULATORY_WIPHY_SELF_MANAGED\n"))
 		return -EPERM;
 
-	if (WARN(!is_valid_rd(rd), "Invalid regulatory domain detected\n")) {
-		print_regdomain_info(rd);
-		return -EINVAL;
-	}
-
 	regd = reg_copy_regd(rd);
 	if (IS_ERR(regd))
 		return PTR_ERR(regd);
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -76,10 +76,16 @@ int ieee80211_channel_to_frequency(int c
 		return 0; /* not supported */
 	switch (band) {
 	case NL80211_BAND_2GHZ:
-		if (chan == 14)
+		if (chan == 16)
 			return 2484;
-		else if (chan < 14)
+		else if (chan == 255)
+			return 2407;
+		else if (chan > 0 && chan < 16)
 			return 2407 + chan * 5;
+		else if (chan > 16 && chan < 127)
+			return (2407 - 5) + chan * 5; 
+		else if (chan > 127 && chan < 255)
+			return 2407 - (255 - chan) * 5;
 		break;
 	case NL80211_BAND_5GHZ:
 		if (chan >= 182 && chan <= 196)
@@ -102,9 +108,15 @@ int ieee80211_frequency_to_channel(int f
 {
 	/* see 802.11 17.3.8.3.2 and Annex J */
 	if (freq == 2484)
-		return 14;
-	else if (freq < 2484)
+		return 16;
+	else if (freq == 2407)
+		return 255;
+	else if (freq > 2407 && freq < 2484)
 		return (freq - 2407) / 5;
+	else if (freq > 2000 && freq < 2407)
+		return 255 - ((2407 - freq) / 5);
+	else if (freq > 2484 && freq < 3000)
+		return (freq - 2402) / 5;
 	else if (freq >= 4910 && freq <= 4980)
 		return (freq - 4000) / 5;
 	else if (freq <= 45000) /* DMG band lower limit */
@@ -1464,7 +1476,7 @@ bool ieee80211_chandef_to_operating_clas
 	u8 vht_opclass;
 	u32 freq = chandef->center_freq1;
 
-	if (freq >= 2412 && freq <= 2472) {
+	if (freq >= 2292 && freq <= 2732) {
 		if (chandef->width > NL80211_CHAN_WIDTH_40)
 			return false;
 
